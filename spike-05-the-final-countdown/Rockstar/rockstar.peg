@namespace Rockstar
@classname Parser
@using System.Globalization
@using Rockstar.Statements
@using Rockstar.Expressions

@ignorecase true

program <Prögram>
	= EOS* EOF
		{ new Prögram() }
	/  _? stmt:statement _ EOF
		{ new Prögram(stmt) }
	/  _? head:statement EOS+ tail:program
		{ tail.Insert(head) }

EOS	= _? '\r'? '\n'

EOF	= !.

statement <Statement>
	= assign_stmt
	/ output_stmt

assign_stmt <Statement>
	= v:variable _ assign _ e:expression { new Assign(v, e) }

output_stmt  <Statement>
	= output _ e:expression { new Output(e) }

variable <Variable>
	= name:("" [a-z]+) { new Variable(name) }

expression <Expression>
	= variable
	/ unary

unary <Expression>
	= op:unary_op ex:expression { new Unary(op, ex) }
	/ boolean

boolean = nor

nor	 <Expression>
	= lhs:or _ 'nor' rhs:or
		{ new Binary(Operator.Nor, lhs, rhs) }
	/ or

or	 <Expression>
	= lhs:and _ 'or' _ rhs:and
		{ new Binary(Operator.Or, lhs, rhs) }
	/ and

and  <Expression>
	= lhs:equals _ 'and' _ rhs:and
		{ new Binary(Operator.And, lhs, rhs) }
	/ equals

equals <Expression>
	= lhs:not op:eq rhs:equals
		{ new Binary(op,lhs,rhs) }
	/ not

not <Expression>
	= 'not' _ ex:not { new Unary(Operator.Not, ex) }
	/ compare

compare <Expression>
	= lhs:math op:comparator _ rhs:compare
		{ new Binary(op, lhs, rhs) }
	/ math

gtr = ("greater"/ "higher"	/ "bigger"	/ "stronger" )
ltr = ("less" / "lower"	/ "smaller" / "weaker" )
gte = ("great" / "high" / "big" / "strong" ) 
lte = ("less" / "low" / "small" / "weak" )

comparator <Operator>
	= is _ gtr _ 'than' { Operator.GreaterThan }
	/ is _ ltr _ 'than' { Operator.LessThan }
	/ is _ 'as' _ gte _ 'as' { Operator.GreaterThanEqual }
	/ is _ 'as' _ lte _ 'as' { Operator.LessThanEqual }

eq = is

is <Operator>
	= ("'s" / "'re" / _ ('=' / 'is' / 'was' / 'are' / 'were'))
		{ Operator.Equals }

math <Expression>
	= sum

sum <Expression> -memoize
	= lhs:sum op:(plus/minus) rhs:product { new Binary(op, lhs, rhs) }
	/ product

product <Expression> -memoize
	= lhs:product op:(times/divide) rhs:literal { new Binary(op, lhs, rhs) }
	/ literal

plus	<Operator>	= (_? '+' _? / _ 'plus' _ / _ 'with' ) { Operator.Plus }
minus	<Operator>	= (_? '-' _? / _ 'minus' _ / _ 'without' _ ) { Operator.Minus }
times	<Operator>	= (_? '*' _? / _ 'times' _ / _ 'of' _ ) { Operator.Times }
divide	<Operator>	= (_? '/' _? / _ 'over' _ / _ 'between' _ ) { Operator.Divide }

literal <Expression>
	= number
	/ string

string <Strïng>
	= '"' contents:("" [^"]*) '"' { new Strïng(contents) }

number <Number>
    = digits:([0-9]+ ("." [0-9]+)?) { new Number(Decimal.Parse(digits)) }

unary_op <Operator>
	= "-" { Operator.Minus }

_           = (whitespace / comment)+

assign		= "is" / "are" / "was" / "were"
output		= "shout" / "say" / "scream" / "whisper"

whitespace  = [ \t]
comment     = '(' [^)]* ')' / '{' [^\}]* '}' / '[' [^\]]* ']'
