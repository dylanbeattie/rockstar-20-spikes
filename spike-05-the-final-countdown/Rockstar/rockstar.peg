@namespace Rockstar
@classname Parser
@using System.Globalization
@using Rockstar.Statements
@using Rockstar.Expressions

@ignorecase true

program <Progräm>
	= __ EOF
		{ new Progräm() }
	/ __ stmt:statement EOS* EOF
		{ new Progräm(stmt) }
	/ __ head:statement EOS+ tail:program
		{ tail.Insert(head) }
	/ #error{ "Error at line " + state.Line + ", col " + state.Column }

__ = _? EOS*
EOS	= _? EOL _?
EOL = '\r'? '\n'
EOF	= !.
	
statement <Statement>
	= assign_stmt
	/ output_stmt

assign_stmt <Statement>
	= v:variable _ 'says' _ s:("" .*) EOL { new Assign(v, new Strïng(s, state.Line, state.Column, s), state.Line, state.Column) }
	/ v:variable _ assign _ e:expression { new Assign(v, e, state.Line, state.Column) }

output_stmt  <Statement>
	= output _ e:expression { new Output(e, state.Line, state.Column) }

variable <Variable>
	= name:("" [a-z]+) { new Variable(name, state.Line, state.Column, name) }

expression <Expression>
	= unary
	/ variable

unary <Expression>
	= op:unary_op ex:expression
		{ new Unary(op, ex, state.Line, state.Column) }
	/ or

// nor	 <Expression>
// 	= lhs:or _ 'nor' rhs:or
// 		{ new Binary(Operator.Nor, lhs, rhs, state.Line, state.Column) }
// 	/ or

or <Expression>
	= lhs:and _ 'or' _ rhs:or
		{ new Binary(Operator.Or, lhs, rhs, state.Line, state.Column) }
	/ and

and <Expression>
	= lhs:equals _ 'and' _ rhs:and
		{ new Binary(Operator.And, lhs, rhs, state.Line, state.Column) }
	/ equals

equals <Expression>
	= lhs:not op:eq rhs:equals
		{ new Binary(op,lhs,rhs, state.Line, state.Column) }
	/ not

not <Expression>
	= 'not' _ ex:not { new Unary(Operator.Not, ex, state.Line, state.Column) }
	/ compare

compare <Expression>
	= lhs:math op:comparator _ rhs:compare
		{ new Binary(op, lhs, rhs, state.Line, state.Column) }
	/ math

gtr = ("greater"/ "higher"	/ "bigger"	/ "stronger" )
ltr = ("less" / "lower"	/ "smaller" / "weaker" )
gte = ("great" / "high" / "big" / "strong" ) 
lte = ("less" / "low" / "small" / "weak" )

comparator <Operator>
	= is _ gtr _ 'than' { Operator.GreaterThan }
	/ is _ ltr _ 'than' { Operator.LessThan }
	/ is _ 'as' _ gte _ 'as' { Operator.GreaterThanEqual }
	/ is _ 'as' _ lte _ 'as' { Operator.LessThanEqual }

eq = is

is <Operator>
	= ("'s" / "'re" / _ ('=' / 'is' / 'was' / 'are' / 'were'))
		{ Operator.Equals }

math <Expression>
	= sum

sum <Expression> -memoize
	= lhs:sum op:(plus/minus) rhs:product { new Binary(op, lhs, rhs, state.Line, state.Column) }
	/ product

product <Expression> -memoize
	= lhs:product op:(times/divide) rhs:primary { new Binary(op, lhs, rhs, state.Line, state.Column) }
	/ primary

plus	<Operator>	= (_? '+' _? / _ 'plus' _ / _ 'with' ) { Operator.Plus }
minus	<Operator>	= (_? '-' _? / _ 'minus' _ / _ 'without' _ ) { Operator.Minus }
times	<Operator>	= (_? '*' _? / _ 'times' _ / _ 'of' _ ) { Operator.Times }
divide	<Operator>	= (_? '/' _? / _ 'over' _ / _ 'between' _ ) { Operator.Divide }

primary <Expression>
	= literal
	/ lookup

lookup <Expression>
	= v:variable { new Looküp(v, state.Line, state.Column) }

literal <Expression>
	= constant
	/ number
	/ string

constant <Expression>
	= true
	/ false

true <Expression>
	= keyword:("true" / "yes" / "ok" / "right")
		{ new True(state.Line, state.Column, keyword) }

false <Expression>
	= keyword:("false" / "lies" / "no" / "wrong")
		{ new False(state.Line, state.Column, keyword) }

string <Strïng>
	= '"' contents:("" [^"]*) '"' { new Strïng(contents, state.Line, state.Column, contents) }

number <Number>
    = digits:([0-9]+ ("." [0-9]+)?) { new Number(Decimal.Parse(digits), state.Line, state.Column, digits) }

unary_op <Operator>
	= "-" { Operator.Minus }

_           = (whitespace / comment)+

assign		= "is" / "are" / "was" / "were"
output		= "shout" / "say" / "scream" / "whisper"

whitespace  = [ \t]
comment     = '(' [^)]* ')' / '{' [^\}]* '}' / '[' [^\]]* ']'
